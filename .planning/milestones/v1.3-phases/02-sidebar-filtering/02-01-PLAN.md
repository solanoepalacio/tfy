---
phase: 02-sidebar-filtering
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - content-script.js
autonomous: true
requirements: [FILT-01, FILT-02, FILT-03]

must_haves:
  truths:
    - "Off-topic sidebar suggestions are visually collapsed to 20px height with a 'hidden: off-topic' label visible"
    - "Suggestions from the same category as the current video remain fully visible"
    - "All sidebar video categories are fetched in a single batched API call (not one per item)"
    - "Previously-fetched video categories are not re-fetched on the same watch session"
    - "Filtering runs on the initial sidebar render within ~1 second of page load"
    - "Lazily-loaded sidebar items (added by scroll) are filtered as they appear"
  artifacts:
    - path: "content-script.js"
      provides: "Full sidebar filtering engine"
      contains: "injectTFYStyles"
    - path: "content-script.js"
      provides: "Session-only category cache"
      contains: "sessionCategoryCache"
    - path: "content-script.js"
      provides: "MutationObserver-based lazy item detection"
      contains: "observeSidebar"
    - path: "content-script.js"
      provides: "initForVideo orchestration function"
      contains: "initForVideo"
  key_links:
    - from: "content-script.js filterSidebar()"
      to: "service-worker.js GET_VIDEO_CATEGORY handler"
      via: "chrome.runtime.sendMessage with videoIds array"
      pattern: "sendMessage.*GET_VIDEO_CATEGORY"
    - from: "content-script.js MutationObserver callback"
      to: "filterSidebar()"
      via: "callback invocation when ytd-compact-video-renderer nodes added"
      pattern: "observeSidebar.*filterSidebar"
    - from: "content-script.js initForVideo()"
      to: "currentCategoryId"
      via: "response.categories[videoId] assignment before filterSidebar() is called"
      pattern: "currentCategoryId = response\\.categories"
---

<objective>
Extend content-script.js with the complete sidebar filtering engine: CSS collapse styles, video ID extraction helpers, a session-only category cache, the filterSidebar() function, and a MutationObserver that applies filtering as YouTube lazily adds more sidebar items. Introduce an initForVideo(videoId) orchestrator that sequences: fetch current video category → set currentCategoryId → run initial filter pass → arm MutationObserver.

Purpose: Deliver the core algorithmic work of Phase 2. The navigation handler wiring (Plan 02) builds on this foundation.

Output: A fully functional sidebar filtering engine in content-script.js, ready to be triggered by navigation events in Plan 02.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-sidebar-filtering/02-RESEARCH.md
@.planning/phases/01-extension-foundation-category-detection/01-02-SUMMARY.md
@content-script.js
@service-worker.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: CSS injection and sidebar video ID extraction helpers</name>
  <files>content-script.js</files>
  <action>
Add the following at the top of content-script.js (before the existing Category Lookup section), keeping all existing code intact below:

1. `injectTFYStyles()` — injects a single `<style id="tfy-styles">` tag into document.head exactly once. CSS rules:
   ```css
   ytd-compact-video-renderer.tfy-hidden {
     max-height: 20px !important;
     overflow: hidden !important;
     opacity: 0.5;
   }
   ytd-compact-video-renderer.tfy-hidden::before {
     content: 'hidden: off-topic';
     display: block;
     font-size: 11px;
     color: #888;
     padding: 2px 8px;
     line-height: 16px;
   }
   ```
   Use `max-height: 20px` (NOT 0) so the ::before label text remains visible (overflow:hidden clips children — 20px exposes the label line). Guard with `if (document.getElementById('tfy-styles')) return;` to prevent double-injection.

2. `extractVideoIdFromRenderer(el)` — accepts a `ytd-compact-video-renderer` element, finds `el.querySelector('a[href*="watch?v="]')`, parses the URL with `new URL(anchor.href).searchParams.get('v')`, returns the video ID string or null on failure. Wrap in try/catch.

3. `collapseElement(el)` — adds class `tfy-hidden` to the element.

4. `resetAllCollapsed()` — removes `tfy-hidden` class from all elements that have it: `document.querySelectorAll('.tfy-hidden').forEach(el => el.classList.remove('tfy-hidden'))`.

Call `injectTFYStyles()` immediately at module-level (not inside a function) so styles are available before any filtering runs.
  </action>
  <verify>
    <automated>node -e "
const fs = require('fs');
const src = fs.readFileSync('/home/solanoe/code/tfy/content-script.js', 'utf8');
const checks = [
  ['injectTFYStyles', src.includes('injectTFYStyles')],
  ['tfy-styles id guard', src.includes(\"document.getElementById('tfy-styles')\")],
  ['max-height 20px', src.includes('max-height: 20px')],
  ['::before label', src.includes('hidden: off-topic')],
  ['extractVideoIdFromRenderer', src.includes('extractVideoIdFromRenderer')],
  ['collapseElement', src.includes('collapseElement')],
  ['resetAllCollapsed', src.includes('resetAllCollapsed')],
  ['injectTFYStyles() call at module level', /^injectTFYStyles\(\)/m.test(src)],
];
checks.forEach(([name, ok]) => console.log((ok ? 'PASS' : 'FAIL') + ': ' + name));
process.exit(checks.every(([,ok]) => ok) ? 0 : 1);
"
    </automated>
    <manual>Verify content-script.js has the new helper functions above the existing Category Lookup section and that existing code is unchanged below.</manual>
  </verify>
  <done>All 8 checks pass. content-script.js now has CSS injection, ID extraction, and collapse helpers without breaking existing category lookup code.</done>
</task>

<task type="auto">
  <name>Task 2: Session cache, filterSidebar(), MutationObserver, and initForVideo() orchestrator</name>
  <files>content-script.js</files>
  <action>
Add the following sections to content-script.js (after the helpers from Task 1, before the existing SPA Navigation section):

**Module-level state variables** (add near top, after helper functions):
```javascript
let currentCategoryId = null;  // category of the currently-watched video
let sidebarObserver = null;    // MutationObserver instance
const sessionCategoryCache = new Map(); // videoId -> categoryId, reset on navigation
```

**`filterSidebar()` async function:**
- Guard: `if (!currentCategoryId) return;`
- Collect all `ytd-compact-video-renderer` elements from the DOM
- Build `idToRenderer` Map: call `extractVideoIdFromRenderer(el)` for each, skip nulls
- Determine `unknownIds` = IDs not yet in `sessionCategoryCache`; slice to 50 max
- If `unknownIds.length > 0`: send `chrome.runtime.sendMessage({ type: 'GET_VIDEO_CATEGORY', videoIds: unknownIds })`. On success, populate `sessionCategoryCache` with `response.categories` entries. On error/null response, log `[TFY] Sidebar filter: category fetch failed` and return.
- For each entry in `idToRenderer`: if `sessionCategoryCache.get(id)` is defined AND not equal to `currentCategoryId`, call `collapseElement(el)`. Do NOT collapse items whose category is unknown (API might have missed them).
- Log `[TFY] Sidebar filter: collapsed N of M suggestions` using counts.

**`observeSidebar(callback)` function:**
- Find `const container = document.querySelector('#secondary')`
- If not found: `setTimeout(() => observeSidebar(callback), 300)` and return
- Create `sidebarObserver = new MutationObserver((mutations) => { ... })`
- Inside callback: iterate `mutations`, for each `mutation.addedNodes`, check if node is `Element` and either `matches('ytd-compact-video-renderer')` or has descendants via `querySelectorAll('ytd-compact-video-renderer')`. If any are found, call `callback()`.
- Call `sidebarObserver.observe(container, { childList: true, subtree: true })`

**`disconnectSidebarObserver()` function:**
- If `sidebarObserver` is set: call `.disconnect()`, set to null.

**`initForVideo(videoId)` async function** — the orchestrator called on every navigation:
1. Fetch current video's category: `const response = await chrome.runtime.sendMessage({ type: 'GET_VIDEO_CATEGORY', videoIds: [videoId] })`
2. Handle null response with single retry after 500ms (same pattern as existing `fetchAndLogCategory`).
3. If `response?.categories?.[videoId]`: set `currentCategoryId = response.categories[videoId]` and log `[TFY] Current video category: ${currentCategoryId}`
4. Else: log `[TFY] Could not determine current video category — sidebar filtering skipped` and return.
5. Call `await filterSidebar()` — initial pass on already-rendered sidebar items
6. Call `observeSidebar(filterSidebar)` — arm observer for lazy items
7. Also schedule a delayed initial pass: `setTimeout(filterSidebar, 1000)` to catch items rendered between observer-attach and first MutationObserver callback.

Note: `sessionCategoryCache` is reset on navigation — that reset happens in the navigation handlers (Plan 02 will update those). initForVideo() does NOT clear the cache — the navigation handler does.
  </action>
  <verify>
    <automated>node -e "
const fs = require('fs');
const src = fs.readFileSync('/home/solanoe/code/tfy/content-script.js', 'utf8');
const checks = [
  ['currentCategoryId variable', src.includes('let currentCategoryId = null')],
  ['sidebarObserver variable', src.includes('let sidebarObserver = null')],
  ['sessionCategoryCache Map', src.includes('sessionCategoryCache = new Map()')],
  ['filterSidebar function', src.includes('async function filterSidebar()')],
  ['filterSidebar guard', src.includes('if (!currentCategoryId) return')],
  ['sessionCategoryCache usage in filterSidebar', src.includes('sessionCategoryCache.get(id)')],
  ['observeSidebar function', src.includes('function observeSidebar(')],
  ['MutationObserver creation', src.includes('new MutationObserver(')],
  ['#secondary selector', src.includes(\"'#secondary'\")],
  ['disconnectSidebarObserver function', src.includes('function disconnectSidebarObserver(')],
  ['initForVideo function', src.includes('async function initForVideo(')],
  ['initForVideo calls filterSidebar', src.includes('await filterSidebar()')],
  ['initForVideo arms observer', src.includes('observeSidebar(filterSidebar)')],
  ['1000ms delayed pass', src.includes('setTimeout(filterSidebar, 1000)')],
];
checks.forEach(([name, ok]) => console.log((ok ? 'PASS' : 'FAIL') + ': ' + name));
process.exit(checks.every(([,ok]) => ok) ? 0 : 1);
"
    </automated>
    <manual>Review that filterSidebar() correctly guards on currentCategoryId, fetches only unknown IDs from sessionCategoryCache, and collapseElement() is called only for off-topic items.</manual>
  </verify>
  <done>All 14 checks pass. content-script.js has a complete filtering engine: session cache prevents redundant API calls, MutationObserver handles lazy items, initForVideo() sequences the async flow correctly.</done>
</task>

</tasks>

<verification>
Run both verify commands in sequence. Both must exit 0. Confirm content-script.js still contains all original Phase 1 code (fetchAndLogCategory, initial load extraction, both navigation handlers) — nothing should be removed, only added.

```bash
grep -c "fetchAndLogCategory\|YT_NAVIGATION\|yt-navigate-finish" /home/solanoe/code/tfy/content-script.js
```
Expected: 6 or more matches (original code preserved).
</verification>

<success_criteria>
- content-script.js has CSS injection producing a visible "hidden: off-topic" label at 20px height
- Off-topic sidebar items get class `tfy-hidden` applied; same-category items are untouched
- Batched API call via existing GET_VIDEO_CATEGORY message — one call for up to 50 sidebar IDs
- Session cache prevents re-fetching already-known video categories within a watch session
- MutationObserver on #secondary fires for lazily-added ytd-compact-video-renderer items
- initForVideo() correctly sequences: fetch current category → set currentCategoryId → initial filter → arm observer
- All existing Phase 1 code preserved and functional
</success_criteria>

<output>
After completion, create `.planning/phases/02-sidebar-filtering/02-01-SUMMARY.md`
</output>
