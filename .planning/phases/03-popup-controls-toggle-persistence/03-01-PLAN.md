---
phase: 03-popup-controls-toggle-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - popup.html
  - popup.js
  - content-script.js
  - manifest.json
autonomous: true
requirements:
  - POPU-01
  - CORE-04

must_haves:
  truths:
    - "Popup shows a checkbox toggle labeled 'Enable filtering' that reflects current filteringEnabled state from chrome.storage.local"
    - "Clicking the toggle writes filteringEnabled to chrome.storage.local and immediately sends TFY_TOGGLE message to the active YouTube watch tab"
    - "Content script reads filteringEnabled from chrome.storage.local before calling initForVideo on page load; skips filtering if disabled"
    - "Content script handles TFY_TOGGLE message: updates module-level filteringEnabled variable, disconnects observer and resets collapsed state when disabled, calls initForVideo again when re-enabled"
    - "MutationObserver does not re-collapse items when filtering is disabled (observer is disconnected on toggle-off)"
  artifacts:
    - path: "popup.html"
      provides: "Toggle checkbox UI element below API key section"
      contains: "id=\"toggle-filtering\""
    - path: "popup.js"
      provides: "Reads filteringEnabled on DOMContentLoaded; writes on change; sends TFY_TOGGLE to active YouTube watch tab"
      contains: "TFY_TOGGLE"
    - path: "content-script.js"
      provides: "Module-level filteringEnabled variable; async IIFE for initial load; TFY_TOGGLE handler in onMessage listener"
      contains: "filteringEnabled"
    - path: "manifest.json"
      provides: "activeTab permission for popup-to-tab messaging"
      contains: "activeTab"
  key_links:
    - from: "popup.js"
      to: "chrome.storage.local"
      via: "chrome.storage.local.set({ filteringEnabled })"
      pattern: "storage\\.local\\.set.*filteringEnabled"
    - from: "popup.js"
      to: "content-script.js"
      via: "chrome.tabs.sendMessage with type TFY_TOGGLE"
      pattern: "tabs\\.sendMessage.*TFY_TOGGLE"
    - from: "content-script.js"
      to: "chrome.storage.local"
      via: "chrome.storage.local.get('filteringEnabled') in async IIFE"
      pattern: "storage\\.local\\.get.*filteringEnabled"
    - from: "content-script.js onMessage"
      to: "disconnectSidebarObserver + resetAllCollapsed"
      via: "TFY_TOGGLE branch in existing onMessage listener"
      pattern: "TFY_TOGGLE"
---

<objective>
Add a filtering toggle to the extension popup and wire it to content-script state persistence.

Purpose: Fulfills POPU-01 (user can toggle filtering on/off) and CORE-04 (toggle state persists across browser restarts). This is the final v1 feature.

Output: Updated popup.html/popup.js with a toggle checkbox, updated content-script.js with startup guard and live toggle handler, updated manifest.json with activeTab permission.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-popup-controls-toggle-persistence/03-RESEARCH.md
@popup.html
@popup.js
@content-script.js
@manifest.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Popup toggle UI and persistence logic</name>
  <files>popup.html, popup.js, manifest.json</files>
  <action>
**popup.html** — add toggle section below the existing `#status` div, before the closing `</body>` tag:

```html
<div style="margin-top: 12px; border-top: 1px solid #eee; padding-top: 10px;">
  <label style="display: flex; align-items: center; gap: 6px; font-size: 12px; cursor: pointer;">
    <input type="checkbox" id="toggle-filtering" style="width: auto;">
    Enable filtering
  </label>
</div>
```

The checkbox uses `id="toggle-filtering"`. Style resets `width: auto` to override the `input { width: 100% }` rule already in the page stylesheet.

**popup.js** — modify the `DOMContentLoaded` handler to also read `filteringEnabled` and set the checkbox state. Add a `change` listener on `#toggle-filtering`. Full updated file:

```javascript
// popup.js — API key management + filtering toggle
// Uses chrome.storage.local (not localStorage — localStorage in content scripts
// writes to youtube.com's storage domain, not the extension's)

document.addEventListener('DOMContentLoaded', async () => {
  const { apiKey } = await chrome.storage.local.get('apiKey');
  if (apiKey) {
    document.getElementById('api-key-input').value = apiKey;
    document.getElementById('status').textContent = 'API key loaded.';
  }

  const { filteringEnabled = true } = await chrome.storage.local.get('filteringEnabled');
  document.getElementById('toggle-filtering').checked = filteringEnabled;
});

document.getElementById('save-btn').addEventListener('click', async () => {
  const key = document.getElementById('api-key-input').value.trim();
  if (!key) {
    document.getElementById('status').textContent = 'Please enter an API key.';
    return;
  }
  await chrome.storage.local.set({ apiKey: key });
  document.getElementById('status').textContent = 'Saved.';
});

document.getElementById('toggle-filtering').addEventListener('change', async (e) => {
  const enabled = e.target.checked;
  await chrome.storage.local.set({ filteringEnabled: enabled });

  const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
  if (tab?.url?.includes('youtube.com/watch')) {
    chrome.tabs.sendMessage(tab.id, { type: 'TFY_TOGGLE', enabled }).catch(() => {});
  }
});
```

Note: The `DOMContentLoaded` listener uses two separate `storage.local.get` calls (one for `apiKey`, one for `filteringEnabled`) to match the existing pattern. Do not batch them into a single call — keep the existing `apiKey` read unchanged.

**manifest.json** — add `"activeTab"` to the `permissions` array (alongside existing `"storage"` and `"webNavigation"`):

```json
"permissions": ["storage", "webNavigation", "activeTab"],
```

`activeTab` is required for `chrome.tabs.query` + `chrome.tabs.sendMessage` from the popup. It grants temporary access to the active tab when the user clicks the extension action — minimal permission footprint vs `"tabs"` which grants broader access.
  </action>
  <verify>
    <automated>node -e "const fs=require('fs'); const h=fs.readFileSync('/home/solanoe/code/tfy/popup.html','utf8'); const j=fs.readFileSync('/home/solanoe/code/tfy/popup.js','utf8'); const m=JSON.parse(fs.readFileSync('/home/solanoe/code/tfy/manifest.json','utf8')); console.assert(h.includes('toggle-filtering'),'popup.html missing toggle'); console.assert(j.includes('TFY_TOGGLE'),'popup.js missing TFY_TOGGLE'); console.assert(j.includes('filteringEnabled = true'),'popup.js missing default'); console.assert(m.permissions.includes('activeTab'),'manifest missing activeTab'); console.log('OK')"</automated>
    <manual>Open popup.html in a browser tab directly (file://) or via the extension — confirm a checkbox labeled "Enable filtering" appears below the API key section and is checked by default.</manual>
  </verify>
  <done>popup.html shows a toggle checkbox; popup.js reads filteringEnabled on load, writes on change, and sends TFY_TOGGLE to the active YouTube watch tab; manifest.json includes "activeTab" permission.</done>
</task>

<task type="auto">
  <name>Task 2: Content script startup guard and TFY_TOGGLE handler</name>
  <files>content-script.js</files>
  <action>
Two changes to `content-script.js`:

**Change 1: Module-level filteringEnabled variable**

Add after the existing module-level variable declarations (after line `let lastProcessedVideoId = null;`):

```javascript
let filteringEnabled = true; // module-level; updated by TFY_TOGGLE message
```

**Change 2: Wrap the Initial Load block in an async IIFE**

The current synchronous initial load block at the bottom of the file:
```javascript
const initialVideoId = new URL(window.location.href).searchParams.get('v');
if (initialVideoId) {
  lastProcessedVideoId = initialVideoId;
  initForVideo(initialVideoId);
}
```

Replace entirely with:
```javascript
// ─── Initial Load ─────────────────────────────────────────────────────────────
// document_idle guarantees the URL reflects the current video.
// Wrapped in async IIFE because content scripts use classic scripts (not ES modules)
// and top-level await is not available without "type": "module" in manifest.
(async () => {
  const { filteringEnabled: storedEnabled = true } = await chrome.storage.local.get('filteringEnabled');
  filteringEnabled = storedEnabled;
  const initialVideoId = new URL(window.location.href).searchParams.get('v');
  if (initialVideoId && filteringEnabled) {
    lastProcessedVideoId = initialVideoId;
    initForVideo(initialVideoId);
  }
})();
```

Note: destructuring alias `filteringEnabled: storedEnabled` avoids shadowing the module-level `filteringEnabled` variable during the destructuring assignment. Then explicitly assign `filteringEnabled = storedEnabled` to update the module-level variable.

**Change 3: Add TFY_TOGGLE branch to the existing onMessage listener**

The existing `chrome.runtime.onMessage.addListener` callback handles `YT_NAVIGATION`. Add a `TFY_TOGGLE` branch before the `YT_NAVIGATION` check:

```javascript
chrome.runtime.onMessage.addListener((message) => {
  if (message.type === 'TFY_TOGGLE') {
    filteringEnabled = message.enabled;
    if (message.enabled) {
      // Re-enable: if we have a current video context, filter immediately
      if (currentCategoryId) {
        filterSidebar();
        observeSidebar(filterSidebar);
      } else if (lastProcessedVideoId) {
        initForVideo(lastProcessedVideoId);
      }
    } else {
      // Disable: reveal all hidden items and stop the observer
      resetAllCollapsed();
      disconnectSidebarObserver();
    }
    return;
  }
  if (message.type === 'YT_NAVIGATION') {
    // ... existing YT_NAVIGATION code unchanged
  }
});
```

The re-enable path uses `currentCategoryId` check (cheaper — avoids API call if category is already known) per the research recommendation. Falls back to `initForVideo` only if `currentCategoryId` was cleared (e.g., navigation happened while disabled).

Keep the `yt-navigate-finish` fallback listener and all `YT_NAVIGATION` handling completely unchanged.

**Important:** Navigation handlers (both `YT_NAVIGATION` and `yt-navigate-finish`) do NOT need to check `filteringEnabled` before calling `initForVideo`. They should always run teardown (resetAllCollapsed, disconnectSidebarObserver, cache clear) and update `lastProcessedVideoId`. The `initForVideo` call inside them should be guarded: only call `initForVideo` if `filteringEnabled` is true. Update both navigation paths:

In the `YT_NAVIGATION` handler, change:
```javascript
initForVideo(message.videoId);
```
to:
```javascript
if (filteringEnabled) initForVideo(message.videoId);
```

In the `yt-navigate-finish` handler, change:
```javascript
initForVideo(videoId);
```
to:
```javascript
if (filteringEnabled) initForVideo(videoId);
```

This ensures navigation teardown always runs (clearing stale state) but filtering only starts if enabled.
  </action>
  <verify>
    <automated>node -e "const fs=require('fs'); const cs=fs.readFileSync('/home/solanoe/code/tfy/content-script.js','utf8'); console.assert(cs.includes('let filteringEnabled = true'),'missing module-level filteringEnabled'); console.assert(cs.includes('TFY_TOGGLE'),'missing TFY_TOGGLE handler'); console.assert(cs.includes('async () =>'),'missing async IIFE'); console.assert(cs.includes('chrome.storage.local.get')&& cs.indexOf('chrome.storage.local.get')!==cs.lastIndexOf('chrome.storage.local.get'),'missing storage read in IIFE'); console.assert(cs.includes('disconnectSidebarObserver'),'missing observer disconnect on toggle-off'); console.log('OK')"</automated>
    <manual>Load extension in Chrome, open DevTools on a YouTube watch page. Confirm no SyntaxError in console. Confirm [TFY] logs appear for category detection.</manual>
  </verify>
  <done>content-script.js has: module-level filteringEnabled=true, async IIFE reading filteringEnabled from storage before initForVideo, TFY_TOGGLE handler that disconnects observer and resets state when disabled, navigation handlers that skip initForVideo when filteringEnabled is false.</done>
</task>

</tasks>

<verification>
Run both automated verify commands from each task. Then:
1. Load the extension in Chrome (chrome://extensions -> reload)
2. Navigate to a YouTube watch page
3. Confirm sidebar filtering runs normally (TFY logs visible in DevTools)
4. Open popup — confirm toggle checkbox is checked
5. Uncheck toggle — sidebar items should immediately un-collapse
6. Re-check toggle — off-topic items should collapse again
7. Close Chrome completely, reopen, navigate to a YouTube watch page
8. Open popup — confirm toggle state was persisted
</verification>

<success_criteria>
- popup.html has id="toggle-filtering" checkbox below API key section
- popup.js reads filteringEnabled with default=true on load; writes on change; sends TFY_TOGGLE to youtube.com/watch tabs
- manifest.json has "activeTab" in permissions array
- content-script.js has module-level filteringEnabled=true variable
- content-script.js initial load wrapped in async IIFE that reads filteringEnabled before calling initForVideo
- content-script.js onMessage has TFY_TOGGLE branch that: updates filteringEnabled, disconnects observer + resets when disabled, calls filterSidebar or initForVideo when re-enabled
- Navigation handlers guard initForVideo with filteringEnabled check
- No syntax errors in content-script.js or popup.js
</success_criteria>

<output>
After completion, create `.planning/phases/03-popup-controls-toggle-persistence/03-01-SUMMARY.md`
</output>
