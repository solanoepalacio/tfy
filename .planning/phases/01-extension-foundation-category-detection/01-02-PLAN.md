---
phase: 01-extension-foundation-category-detection
plan: "02"
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - service-worker.js
  - content-script.js
autonomous: true
requirements:
  - CORE-03
  - CATD-01
  - CATD-02

must_haves:
  truths:
    - "When user navigates to a YouTube watch page, category ID is logged to console"
    - "When user navigates between YouTube videos via SPA (no page reload), each new video's category is logged"
    - "Content script does not call googleapis.com directly (all API calls go through service worker)"
    - "Service worker message listener is registered at top-level (not inside async function)"
  artifacts:
    - path: "service-worker.js"
      provides: "API proxy, SPA navigation relay, YouTube Data API fetch"
      contains: "onHistoryStateUpdated"
    - path: "content-script.js"
      provides: "Video ID extraction, navigation event handling, category log"
      contains: "GET_VIDEO_CATEGORY"
  key_links:
    - from: "content-script.js"
      to: "service-worker.js"
      via: "chrome.runtime.sendMessage({ type: 'GET_VIDEO_CATEGORY', videoIds: [videoId] })"
      pattern: "sendMessage.*GET_VIDEO_CATEGORY"
    - from: "service-worker.js"
      to: "https://www.googleapis.com/youtube/v3/videos"
      via: "fetch() with apiKey from chrome.storage.local"
      pattern: "googleapis\\.com/youtube/v3/videos"
    - from: "service-worker.js"
      to: "content-script.js"
      via: "chrome.tabs.sendMessage({ type: 'YT_NAVIGATION', videoId })"
      pattern: "tabs\\.sendMessage.*YT_NAVIGATION"
    - from: "service-worker.js"
      to: "chrome.storage.local"
      via: "chrome.storage.local.get('apiKey')"
      pattern: "storage\\.local\\.get.*apiKey"
---

<objective>
Implement the full data pipeline: service-worker.js handles YouTube Data API calls and SPA navigation detection, content-script.js extracts the video ID and logs the category on each navigation.

Purpose: This wires together the complete plumbing chain — from "user navigates to a YouTube video" to "category ID appears in the DevTools console." It validates that the message relay architecture works, SPA navigation is detected without page reloads, and the YouTube Data API returns category data.
Output: service-worker.js and content-script.js. Loading the extension and visiting youtube.com/watch pages produces console logs like `[TFY] Video dQw4w9WgXcQ → category 10`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-extension-foundation-category-detection/01-RESEARCH.md
@.planning/phases/01-extension-foundation-category-detection/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create service-worker.js — API proxy and SPA navigation relay</name>
  <files>service-worker.js</files>
  <action>
Create `service-worker.js` at the repo root. This file must implement two responsibilities:

**1. YouTube Data API proxy (handles GET_VIDEO_CATEGORY messages from content script)**

```javascript
// service-worker.js
// CRITICAL: ALL listeners must be registered at top-level — not inside functions or
// async callbacks. Chrome restores top-level listeners when restarting an idle worker.
// Listeners registered inside async functions will be lost after worker termination.

// ─── Message Handler ────────────────────────────────────────────────────────
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.type === 'GET_VIDEO_CATEGORY') {
    // Return true BEFORE async work — keeps the message channel open.
    // Without this, Chrome closes the channel before sendResponse is called.
    handleCategoryRequest(message.videoIds)
      .then(sendResponse)
      .catch(err => sendResponse({ error: err.message }));
    return true; // Keep channel open for async sendResponse
  }
});

async function handleCategoryRequest(videoIds) {
  const { apiKey } = await chrome.storage.local.get('apiKey');
  if (!apiKey) {
    return { error: 'No API key set. Open the extension popup and enter your YouTube Data API v3 key.' };
  }
  return fetchVideoCategories(videoIds, apiKey);
}

async function fetchVideoCategories(videoIds, apiKey) {
  const ids = videoIds.slice(0, 50).join(','); // API max: 50 IDs per request
  const url = new URL('https://www.googleapis.com/youtube/v3/videos');
  url.searchParams.set('part', 'snippet');
  url.searchParams.set('id', ids);
  url.searchParams.set('key', apiKey);

  const res = await fetch(url.toString());
  if (!res.ok) {
    const body = await res.text();
    throw new Error(`YouTube API ${res.status}: ${body.slice(0, 200)}`);
  }
  const data = await res.json();

  const categories = {};
  for (const item of (data.items || [])) {
    categories[item.id] = item.snippet.categoryId;
  }
  return { categories }; // { categories: { videoId: categoryId, ... } }
}
```

**2. SPA Navigation Detection (relays YT_NAVIGATION to content script)**

```javascript
// ─── SPA Navigation Detection ────────────────────────────────────────────────
// youtube.com/watch navigations use pushState — no page reload.
// chrome.webNavigation.onHistoryStateUpdated fires on every pushState call.
// Filter to watch pages only and relay the new videoId to the content script.

chrome.webNavigation.onHistoryStateUpdated.addListener(
  (details) => {
    const url = new URL(details.url);
    const videoId = url.searchParams.get('v');
    if (url.pathname === '/watch' && videoId) {
      // Notify content script — wrap in catch because content script may not
      // be ready yet (e.g., initial tab load race). Failure is non-fatal.
      chrome.tabs.sendMessage(details.tabId, {
        type: 'YT_NAVIGATION',
        videoId
      }).catch(() => {
        // Content script not ready or tab closed — ignore silently
      });
    }
  },
  { url: [{ hostEquals: 'www.youtube.com' }] }
);
```

Combine both sections into a single `service-worker.js` file. Place the `chrome.runtime.onMessage.addListener` block first, then the `chrome.webNavigation.onHistoryStateUpdated.addListener` block. Both must be at the top level of the file.

Anti-patterns to avoid (from RESEARCH.md):
- Do NOT use `XMLHttpRequest` — service workers don't support it; use `fetch()` only
- Do NOT register listeners inside async functions
- Do NOT use `setTimeout`/`setInterval` — service worker is terminated after 30s idle; timers are cancelled
- Do NOT call googleapis.com from content-script.js — Chrome blocks cross-origin requests from content scripts regardless of host_permissions
  </action>
  <verify>
    <automated>node -e "const fs = require('fs'); const sw = fs.readFileSync('/home/solanoe/code/tfy/service-worker.js','utf8'); console.assert(sw.includes('onMessage.addListener'), 'missing onMessage listener'); console.assert(sw.includes('return true'), 'missing return true for async sendResponse'); console.assert(sw.includes('GET_VIDEO_CATEGORY'), 'missing message type handler'); console.assert(sw.includes('onHistoryStateUpdated'), 'missing SPA navigation listener'); console.assert(sw.includes('googleapis.com/youtube/v3/videos'), 'missing YouTube API URL'); console.assert(sw.includes('storage.local.get'), 'missing apiKey read'); console.assert(!sw.includes('XMLHttpRequest'), 'must not use XHR'); console.log('service-worker.js OK');"</automated>
  </verify>
  <done>service-worker.js exists with: top-level onMessage listener handling GET_VIDEO_CATEGORY (with return true), fetchVideoCategories function calling googleapis.com via fetch(), top-level onHistoryStateUpdated listener relaying YT_NAVIGATION to content script.</done>
</task>

<task type="auto">
  <name>Task 2: Create content-script.js — video ID extraction and category logging</name>
  <files>content-script.js</files>
  <action>
Create `content-script.js` at the repo root. This script is injected into youtube.com/watch pages at document_idle. It must:

1. On initial load: extract the video ID from the current URL and request its category
2. On SPA navigation (YT_NAVIGATION message from service worker): detect the new video ID and request its category
3. Fallback: listen to YouTube's `yt-navigate-finish` DOM event in case the service worker message is missed

```javascript
// content-script.js
// Injected into youtube.com/watch* pages at document_idle (URL is stable by then).

// ─── Category Lookup ─────────────────────────────────────────────────────────

async function fetchAndLogCategory(videoId) {
  if (!videoId) return;
  console.log(`[TFY] Detected video: ${videoId}`);

  try {
    const response = await chrome.runtime.sendMessage({
      type: 'GET_VIDEO_CATEGORY',
      videoIds: [videoId]
    });

    if (!response) {
      console.warn('[TFY] No response from service worker — worker may be starting up. Retrying...');
      // Retry once after 500ms to handle service worker cold-start race
      await new Promise(r => setTimeout(r, 500));
      return fetchAndLogCategory(videoId);
    }

    if (response.error) {
      console.error('[TFY] Error:', response.error);
      return;
    }

    const categoryId = response.categories?.[videoId];
    console.log(`[TFY] Video ${videoId} → category ID: ${categoryId}`);
  } catch (err) {
    console.error('[TFY] sendMessage failed:', err.message);
  }
}

// ─── Initial Load ─────────────────────────────────────────────────────────────
// document_idle guarantees the URL reflects the current video
const initialVideoId = new URL(window.location.href).searchParams.get('v');
fetchAndLogCategory(initialVideoId);

// ─── SPA Navigation (Primary: service worker relay) ───────────────────────────
// Service worker detects pushState via webNavigation.onHistoryStateUpdated
// and sends a YT_NAVIGATION message with the new videoId.
chrome.runtime.onMessage.addListener((message) => {
  if (message.type === 'YT_NAVIGATION') {
    fetchAndLogCategory(message.videoId);
  }
});

// ─── SPA Navigation (Fallback: YouTube internal event) ────────────────────────
// yt-navigate-finish is a YouTube-internal custom DOM event fired after the new
// video page finishes rendering. It is undocumented and may change.
// Use only as a belt-and-suspenders fallback alongside the service worker relay.
document.addEventListener('yt-navigate-finish', () => {
  const videoId = new URL(window.location.href).searchParams.get('v');
  fetchAndLogCategory(videoId);
});
```

Implementation notes:
- `new URL(window.location.href).searchParams.get('v')` — standard URLSearchParams, no regex needed
- Single retry on null response handles the service worker cold-start race condition (documented open question in RESEARCH.md)
- Both `chrome.runtime.onMessage` (for service worker relay) and `yt-navigate-finish` (YouTube fallback) ensure navigation is never missed
- The retry is limited to one attempt to avoid infinite loops if the extension truly has no API key configured
- Log prefix `[TFY]` makes it easy to filter extension logs in DevTools console
  </action>
  <verify>
    <automated>node -e "const fs = require('fs'); const cs = fs.readFileSync('/home/solanoe/code/tfy/content-script.js','utf8'); console.assert(cs.includes('GET_VIDEO_CATEGORY'), 'missing message type'); console.assert(cs.includes('searchParams.get(\"v\")'), 'missing video ID extraction'); console.assert(cs.includes('YT_NAVIGATION'), 'missing navigation handler'); console.assert(cs.includes('yt-navigate-finish'), 'missing fallback listener'); console.assert(!cs.includes('fetch('), 'must not call fetch directly — use sendMessage to service worker'); console.assert(cs.includes('[TFY]'), 'missing log prefix'); console.log('content-script.js OK');"</automated>
  </verify>
  <done>content-script.js exists with: initial video ID extraction on load, GET_VIDEO_CATEGORY sendMessage to service worker, YT_NAVIGATION message listener, yt-navigate-finish fallback listener, [TFY] prefixed console.log of category ID.</done>
</task>

</tasks>

<verification>
Run both automated verify commands. Both must pass.

Cross-check manifest wiring:
- `node -e "const m=JSON.parse(require('fs').readFileSync('/home/solanoe/code/tfy/manifest.json','utf8')); console.log(m.background.service_worker, m.content_scripts[0].js);"` should print `service-worker.js [ 'content-script.js' ]`

Static check: ensure `content-script.js` contains no direct `fetch(` calls (all API calls must go through service worker).
</verification>

<success_criteria>
1. service-worker.js handles GET_VIDEO_CATEGORY messages — reads apiKey from chrome.storage.local, fetches googleapis.com/youtube/v3/videos, returns { categories: { videoId: categoryId } }
2. service-worker.js listens to onHistoryStateUpdated for youtube.com/watch URLs and sends YT_NAVIGATION message to tab
3. content-script.js extracts video ID from URL on initial load and calls fetchAndLogCategory
4. content-script.js handles YT_NAVIGATION messages from service worker
5. content-script.js listens to yt-navigate-finish as fallback
6. content-script.js logs `[TFY] Video {id} → category ID: {N}` to console
7. content-script.js does NOT call fetch() directly — all API calls go via chrome.runtime.sendMessage
</success_criteria>

<output>
After completion, create `.planning/phases/01-extension-foundation-category-detection/01-02-SUMMARY.md`
</output>
